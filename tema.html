
<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>esame</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<h2 id="toc_0">Modalità di svolgimento e consegna</h2>

<p>Ogni gruppo deve consegnare il progetto entro <strong>le ore 12:00 del 19/02</strong>, invidando a <a href="mailto:paolo.boldi@unimi.it">paolo.boldi@unimi.it</a> una e-mail dal titolo <em>Consegna Programmazione 2 Febbraio NOMEGRUPPO</em>. La e-mail deve contenere in allegato un file .zip con i sorgenti (.java) e la documentazione (vedi sotto).</p>

<ul>
<li>Oltre ai sorgenti, il file .zip deve contenere

<ul>
<li>un file di nome documentazione.pdf contenente la descrizione del progetto, in particolare per quanto riguarda eventuali deviazioni rispetto al testo qui indicato</li>
<li>un file di nome DatiPersonali.java che deve contenere solo un commento nel seguente formato</li>
</ul></li>
</ul>

<blockquote>
<div><pre><code class="language-none"> /**
 * Nome gruppo: Pippolini
 * Numero partecipanti: 3
 * Partecipante 1: Rossi, Paolo
 * Partecipante 2: De Paperis, Pico
 * Partecipante 3: Del Gaudio, Maria Cristina
 * e-mail di contatto: pippolini@gmail.com
 **/</code></pre></div>
</blockquote>

<h2 id="toc_1">ASCII Art</h2>

<p>L&#39;ASCII art è un mezzo artistico che si basa principalmente sui computer come supporto di presentazione; consiste di immagini prodotte componendo i 95 caratteri ASCII. </p>

<div><pre><code class="language-none">              $$$        $$$$$      $$$$         $$$$     $$$$$
              $$$       $$$$$$$     $$$$         $$$$    $$$$$$$
              $$$       $$$$$$$     $$$$$       $$$$$    $$$$$$$
              $$$       $$$$$$$      $$$$       $$$$     $$$$$$$
              $$$      $$$$ $$$$     $$$$$     $$$$$    $$$$ $$$$
              $$$      $$$$ $$$$      $$$$     $$$$     $$$$ $$$$
              $$$     $$$$$ $$$$$     $$$$     $$$$    $$$$$ $$$$$
              $$$     $$$$   $$$$     $$$$$   $$$$$    $$$$   $$$$
              $$$     $$$$   $$$$      $$$$   $$$$     $$$$   $$$$
              $$$    $$$$$   $$$$$     $$$$$ $$$$$    $$$$$   $$$$$
              $$$    $$$$$$$$$$$$$      $$$$ $$$$     $$$$$$$$$$$$$
      $$$$   $$$$    $$$$$$$$$$$$$      $$$$ $$$$     $$$$$$$$$$$$$
      $$$$   $$$$   $$$$$$$$$$$$$$$      $$$$$$$     $$$$$$$$$$$$$$$
      $$$$$ $$$$$   $$$$       $$$$      $$$$$$$     $$$$       $$$$
      $$$$$$$$$$$  $$$$$       $$$$$     $$$$$$$    $$$$$       $$$$$
       $$$$$$$$$   $$$$         $$$$      $$$$$     $$$$         $$$$
        $$$$$$$    $$$$         $$$$      $$$$$     $$$$         $$$$                           </code></pre></div>

<h2 id="toc_2"> Introduzione</h2>

<p>L&#39;obiettivo di questo esercizio è progettare un tool per disegnare mediante ASCII art.</p>

<h2 id="toc_3">Classi e interfacce</h2>

<p>Descriviamo ora nei dettagli come realizzare le classi necessarie al progetto. Se lo ritenete, potete apportare cambiamenti alle segnature dei metodi proposti ed anche – se lo ritenete – alla struttura delle classi, restando ovviamente all&#39;interno dei requisiti esposti nel paragrafo introduttivo.
La valutazione dipenderà anche da quanto e come avete deciso di estendere le specifiche.</p>

<p><em>N.B.</em>: Oltre ai metodi qui indicati, ricordatevi di aggiungere ad ogni classe un valido metodo <code>toString()</code> e, dove lo ritenete utile, anche un metodo <code>equals</code> e un metodo <code>hashCode</code>.</p>

<h2 id="toc_4"> Classe Canvas</h2>

<p>Tutti i disegni vengono realizzati su un <code>Canvas</code> che rappresenta un rettangolo le cui celle contengono ciascuna un carattere. Il canvas all&#39;inizio è vuoto (cioè, le sue celle contengono il carattere spazio).</p>

<p>Il <code>Canvas</code> ha una dimensione (R righe per C colonne) stabilita all&#39;atto della costruzione: ogni cella è identificata da una coppia (x,y) dove x varia da 0 a C-1 e y varia da 0 a R-1. La cella in basso a sinistra è la cella (0,0), quella in alto a destra è la cella (C-1,R-1).</p>

<p>La classe ha i seguenti metodi:</p>

<ul>
<li><code>getR()</code>: restituisce il numero di righe di questo canvas.</li>
<li><code>getC()</code>: restituisce il numero di colonne di questo canvas.</li>
<li><code>car(int x, int y)</code>: restituisce il carattere che si trova attualmente nella cella (x,y).</li>
<li><code>vuota(int x, int y)</code>: dice se la cella (x,y) è vuota (cioè, se contiene il carattere spazio).</li>
<li><code>modifica(int x, int y, char c)</code>: mette il carattere c nella cella (x,y). Se x o y non hanno valori corretti (ad esempio, sono negativi o &ge; del massimo consentito), il metodo non deve sollevare eccezioni ma semplicemente non deve fare niente.</li>
<li><code>modifica(int x1, int y1, int x2, int y2, char c)</code>: disegna un segmento con le estremità indicate usando il carattere c. Naturalmente lo farà in modo approssimato compatibile con la limitata risoluzione del canvas.  Se gli estremi sono (uno o entrambi) fuori dal canvas, il metodo disegnerà solo la parte eventualmente visibile del segmento.</li>
<li><code>undo(int k)</code>: il canvas torna allo stato in cui si trovava <code>k</code> modifiche fa (o allo stato iniziale se ci sono state meno di <code>k</code> modifiche).</li>
<li><code>copia()</code>: restituisce un nuovo canvas che ha le stesse dimensioni e lo stesso contenuto del canvas su cui è invocato. </li>
<li><code>copia(int x1, int y1, int x2, int y2)</code>: restituisce un nuovo canvas che è una copia del rettangolo i cui estremi sono dati dai punti (x1,y1) e (x2,y2).</li>
<li><code>toString()</code>: restituisce una stringa stampabile che mostra il canvas.</li>
</ul>

<h2 id="toc_5">Interfaccia Evento</h2>

<p>Il tool che dovete progettare reagisce a degli eventi, in modalità che verranno in seguito specificate. Non c&#39;è bisogno che realizziate alcuna vera interazione fra l&#39;utente e il tool (anche se daremo dei suggerimenti su come farlo alla fine del testo, nel caso lo vogliate fare): gli eventi che descriveremo sono solo virtuali.</p>

<p>L&#39;interfaccia <code>Evento</code> è un&#39;interfaccia vuota (senza metodi), cioè una cosiddetta <em>marker interface</em>. </p>

<p>E&#39; implementata da due classi, che si chiamano <code>EventoDiTastiera</code> e <code>EventoDiMouse</code>.</p>

<h3 id="toc_6">Classe EventoDiTastiera</h3>

<p>Rappresenta il fatto che l&#39;utente abbia premuto un tasto sulla tastiera.
Ha un costruttore opportuno e i seguenti metodi:</p>

<ul>
<li><code>car()</code>: restituisce il carattere corrispondente al tasto premuto.</li>
</ul>

<h3 id="toc_7">Classe EventoDiMouse</h3>

<p>Rappresenta il fatto che l&#39;utente abbia interagito con il mouse. Ogni evento di mouse corrisponde a una posizione sul canvas che si sta utilizzando. Tale posizione (insieme al canvas utilizzato) è specificata nel costruttore, ed è restituita dal metodo:</p>

<ul>
<li><code>posx()</code>: restituisce la coordinata x della posizione in cui si è verificato l&#39;evento.</li>
<li><code>posy()</code>: restituisce la coordinata y della posizione in cui si è verificato l&#39;evento.</li>
</ul>

<p>La classe ha varie sottoclassi che corrispondono a diversi tipi di eventi di mouse.</p>

<h4 id="toc_8">Classe MouseMove</h4>

<p>Corrisponde al fatto che il mouse è stato spostato e ora si trova nella posizione indicata.</p>

<h4 id="toc_9">Classe MouseClick</h4>

<p>Corrisponde al fatto che l&#39;utente ha fatto click su uno dei due tasti del mouse nella posizione indicata.
Il metodo:</p>

<ul>
<li><code>rightClick()</code>: dice se è stato premuto il tasto di destra (se è false, vuol dire che è stato premuto il tasto di sinistra).</li>
<li><code>doubleClick()</code>: dice se è stato un doppio click.</li>
</ul>

<h4 id="toc_10">Classe DragStart</h4>

<p>Corrisponde al fatto che l&#39;utente ha premuto uno dei tasti del mouse e, mantenendolo premuto, sta spostando il mouse. Tale azione viene detta <em>drag</em>. </p>

<p>Ha il metodo: </p>

<ul>
<li><code>right()</code>: dice se è stato premuto il tasto di destra (se è false, vuol dire che è stato premuto il tasto di sinistra).</li>
</ul>

<h4 id="toc_11">Classe DragEnd</h4>

<p>Indica che l&#39;utente ha rilasciato il tasto terminando una precedente azione di drag. L&#39;evento DragEnd si può verificare solo dopo un DragStart, e fra il DragStart e il DragEnd si possono essere solo verificate delle MouseMove. Viceversa, dopo ogni DragStart si verificheranno una serie di MouseMove terminate da un DragEnd.</p>

<h2 id="toc_12">Classe astratta Strumento</h2>

<p>Esistono vari strumenti ognuno dei quali modifica il canvas in modi diversi. Tali strumenti reagiscono a eventi di mouse (non necessariamente a tutti; in alcuni casi la reazione dipende non solo dall&#39;evento che si è verificato ma anche dalla storia precedente).</p>

<p>La classe riceve il <code>Canvas</code> nel costruttore e ha un metodo:</p>

<ul>
<li><code>ricevi(EventoDiMouse e)</code></li>
</ul>

<p>che è astratto e viene implementato nelle sottoclassi. Tipicamente, le implementazioni reagiranno ad alcuni eventi modificando in modo opportuno il <code>Canvas</code>.</p>

<h3 id="toc_13">Classe astratta StrumentoDiDisegno</h3>

<p>Uno <code>StrumentoDiDisegno</code> è uno strumento che serve per disegnare. In ogni istante, è definito un carattere che viene chiamato <em>tratto di disegno</em> ed è il carattere che si usa per disegnare. Tale carattere all&#39;inizio è sempre il carattere <code>*</code>ma può essere modificato dal metodo:</p>

<ul>
<li><code>setTratto(char c)</code>: d&#39;ora in avanti userà il carattere c per disegnare.</li>
</ul>

<h4 id="toc_14">Classe Segmento</h4>

<p>Un Segmento è uno StrumentoDiDisegno che reagisce solo a eventi <code>DragStart</code> e <code>DragEnd</code>, e solo nel caso che tali eventi si verifichino con il tasto di sinistra del mouse.</p>

<p>Quando avviene l&#39;evento di <code>DragEnd</code> viene tracciato un segmento che unisce il punto di partenza (dove è iniziato il drag) al punto di arrivo (dove è finito il drag). Ovviamente, tale segmento sarà per forza di cose approssimato (al livello di risoluzione dei caratteri). Il segmento sarà tracciato usando il tratto attualmente in uso.</p>

<h4 id="toc_15">Classe Poligonale</h4>

<p>Questa classe rappresenta uno StrumentoDiDisegno che serve per disegnare una sequenza di segmenti. Reagisce solo a click del mouse.
* Il primo click di sinistra (semplice) determina l&#39;inizio di una poligonale.
* Ogni successivo click di sinistra (semplice) traccia un segmento fra il punto precedente e quello corrente.
* Un eventuale doppio click di sinistra riunisce l&#39;ultimo punto con quello di partenza e termina la poligonale corrente.
* Un click di destra (semplice o doppio) resetta lo stato dello strumento.</p>

<h4 id="toc_16">Classe DisegnoAManoLibera</h4>

<p>Questo strumento rappresenta uno StrumentoDiDisegno. In ogni istante lo strumento può essere attivo o non attivo (all&#39;inizio, non è attivo); per fargli cambiare stato (da attivo a non attivo e viceversa) occorre fare un click con il tasto di sinistra. Quando lo strumento non è attivo non fa nulla. Quando è attivo, reagisce a movimenti di mouse disegnando nella cella in cui si trova (con il tratto corrente).</p>

<h4 id="toc_17">Classe Quadrato</h4>

<p>Un Quadrato è uno StrumentoDiDisegno che reagisce solo a eventi <code>DragStart</code> e <code>DragEnd</code>, e solo nel caso che tali eventi si verifichino con il tasto di sinistra del mouse.</p>

<p>Quando avviene l&#39;evento di <code>DragEnd</code> viene tracciato un quadrato che ha come vertici contrapposti il punto di partenza (dove è iniziato il drag) e il punto di arrivo (dove è finito il drag). </p>

<h4 id="toc_18">Classe Cerchio</h4>

<p>Un Cerchio è uno StrumentoDiDisegno per disegnare circonferenze approssimate. Reagisce solo a eventi di click. Il primo click (effettuato con il tasto di sinistra) marca il centro, il successivo click indica un punto sulla circonferenza e traccia effettivamente la circonferenza stessa (usando il tratto attualmente scelto). Dopo il secondo click lo strumento è pronto per disegnare altre circonferenze.
Qualunque click effettuato con il tasto di destra resetta lo stato (riporta lo strumento allo stato iniziale).</p>

<h3 id="toc_19">Classe astratta StrumentoDiSelezione</h3>

<p>Uno strumento di selezione è uno strumento che funziona come segue: all&#39;inizio reagisce esclusivamente a eventi di drag effettuati con il tasto di sinistra (ignora qualunque altro evento). Dopo che è terminato un evento di drag, il rettangolo di canvas individuato dai due punti di inizio e fine del drag viene chiamato <em>area selezionata</em>.</p>

<p>Se dopo aver selezionato un&#39;area si verifica qualsiasi evento che non sia una move o un click con il tasto di sinistra, la selezione viene persa e lo strumento si resetta (preparandosi a selezionare un&#39;area, come all&#39;inizio).</p>

<p>Se invece si verifica un click con il tasto di sinistra, viene invocato il metodo astratto:</p>

<ul>
<li><code>azione(int x1, int y1, int x2, int y2, int x, int y)</code>: che svolge una qualche azione (le varie sottoclassi determinano quale), sapendo che l&#39;area selezionata è quella copiata delimitata dal rettangolo di vertici opposti (x1,y1) e (x2,y2), e il punto in cui è avvenuto il click di sinistra (che chiameremo <em>action point</em>) è quello di coordinate (x,y).</li>
</ul>

<h4 id="toc_20">Classe Cancella</h4>

<p>Cancella è uno StrumentoDiSelezione che cancella il contenuto dell&#39;area selezionata. L&#39;action point non è rilevante.</p>

<h4 id="toc_21">Classe Copia</h4>

<p>Copia è uno StrumentoDiSelezione che copia il contenuto dell&#39;area selezionata nel rettangolo che ha l&#39;action point come vertice in alto a sinistra. Notate che questo metodo deve funzionare correttamente anche se il rettangolo sorgente e il rettangolo destinazione si sovrappongono in parte.</p>

<h4 id="toc_22">Classi FlipHoriz e FlipVert</h4>

<p>FlipHoriz e FlipVert sono due strumenti di selezione che modificano il contenuto dell&#39;area selezionata; in particolare, su tale contenuto viene applicata una simmetria rispetto a un asse verticale e orizzontale (rispettivamente) centrato rispetto al rettangolo selezionato.</p>

<p>Supponete ad esempio che il rettangolo selezionato sia quello indicato sotto e delimitato (per comodità) da un bordo di asterischi:</p>

<div><pre><code class="language-none">   ******   ***
   *    *
*  **   *
   ***  *     ***AAAAEEE
   **** *
   ******</code></pre></div>

<p>Ecco come comparirà dopo un FlipHoriz:</p>

<div><pre><code class="language-none">   ******   ***
   *    *
*  *   **
   *  ***     ***AAAAEEE
   * ****
   ******</code></pre></div>

<p>Ed ecco come comparirà invece dopo un FlipVert:</p>

<div><pre><code class="language-none">    ******   ***
    **** *
 *  *  ***
    **   *     ***AAAAEEE
    *    *
    ******</code></pre></div>

<h2 id="toc_23">Classe ToolBox</h2>

<p>Un toolbox è un insieme di strumenti ciascuno associato a un carattere in modo univoco, e in cui al più uno strumento è in ogni istante <em>attivo</em>. Il costruttore prende come argomento un <code>Canvas</code> su cui questo toolbox opererà.</p>

<p>All&#39;inizio (alla costruzione) il toolbox è vuoto e non c&#39;è nessuno strumento attivo.
La classe ha inoltre i metodi:</p>

<ul>
<li><code>aggiungi(Strumento s, char c)</code>: aggiunge lo strumento indicato al toolbox, associandovi il carattere c; se il carattere era già associato a uno strumento, questa nuova associazione sovrascrive la vecchia. Aggiungere uno strumento non cambia lo strumento attualmente attivo, se ce n&#39;è uno.</li>
<li><code>ricevi(Evento e)</code>: opera in modi diversi a seconda dell&#39;evento:

<ul>
<li>se si tratta di un evento di tastiera

<ul>
<li>se esiste uno strumento associato a <code>c</code>, quello strumento diventa lo strumento attivo; </li>
<li>se non c&#39;è uno strumento associato a <code>c</code>, e <code>c==&#39;u&#39;</code>, viene fatto sul canvas un (singolo) undo;</li>
<li>in tutti gli altri casi, se attualmente lo strumento attivo è uno strumento di disegno, il carattere premuto diventa il nuovo tratto di disegno</li>
</ul></li>
<li>se si tratta di un evento di mouse e c&#39;è uno strumento selezionato, l&#39;evento viene passato al metodo <code>ricevi</code> dello strumento.</li>
</ul></li>
<li><code>strumenti()</code>: restituisce una <code>Map&lt;Character,Strumento&gt;</code> con una mappa che contiene l&#39;associazione rappresentata da questo toolbox.</li>
<li><code>attivo()</code>: restituisce lo strumento attivo.</li>
<li><code>attiva(char c)</code>: attiva lo strumento associato al carattere <code>c</code>, se ce n&#39;è uno; altrimenti non fa niente.</li>
</ul>

<h2 id="toc_24">Main sperimentale</h2>

<p>Per permettervi di sperimentare con le vostre classi forniamo un&#39;<a href="src/it/unimi/di/boldi/mat/ASCIIArt.java">applicazione java</a> che potete integrare nel vostro progetto. L&#39;unica cosa che dovrete modificare sarà il metodo <code>main</code> di tale applicazione. Lanciandola, avrete un canvas su cui potete provare a vedere l&#39;effetto delle azioni. </p>

<p><strong>NB:</strong> Si tratta di una classe assolutamente sperimentale, usatela solo per verificare visualmente la correttezza del vostro codice.</p>




</body>

</html>
